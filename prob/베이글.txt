1.
# +-1 이내로 1이 있으면 +-1, 없으면 그대로
def solution(n, ladder):
    answer = []
    
    for i in range(n):
        now = i
        for j in range(len(ladder)): #[1,0,1]
            if now == 0 and ladder[j][now] == 1:
                now += 1
            elif now == n-1 and ladder[j][now-1] == 1:
                now -= 1
            elif now > 0 and ladder[j][now-1] == 1:
                now -=1
            elif now < n-1 and ladder[j][now] == 1:
                now += 1
        answer.append(now+1)
    return answer

print(solution(4,[[1,0,1],[0,1,0],[0,0,1],[0,0,0],[1,0,0]]))


2.

def solution(N, relation, dirname):
    dirname = list(map(lambda x:len(x),dirname))
    data=[]
    answer=[]
    # DFS 함수 정의
    def dfs(graph, v, visited):
        # 현재 노드를 방문 처리  
        visited[v] = True
        #print(v, end=' ')
        data.append(v)
        # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
        for i in graph[v]:
            if not visited[i]:
                dfs(graph, i, visited)

        sum=0
        for i in data:
            sum+=dirname[i-1]
        sum += len(data)-1
        answer.append(sum)
        data.pop()
        
    # 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
    graph = [[] for _ in range(N+1)]
    for i in relation: #[1,2]
        graph[i[0]].append(i[1])
        graph[i[1]].append(i[0])

    # 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
    visited = [False] * (N+1)

    # 정의된 DFS 함수 호출
    dfs(graph, 1, visited)
    return max(answer)

print(solution(7, [[1,2],[2,5],[2,6],[1,3],[1,4],[3,7]], ['root','abcd','cs','hello','etc','hello','solution']))

3. 
#1
from collections import Counter

def solution(n, colors):
    counter=Counter(colors)
    data= list(dict(counter).values())
    answer = 0
    for i in data:
        answer += i**2
    return answer

print(solution(10, [1,1,2,2,2,3,3,3,2,2]))
print(solution(10, [1,1,2,2,4,3,4,3,2,2])) #26
print(solution(10, [2,2,3,3,2,2,3,3,2,2])) #44

#2
from itertools import permutations
import copy

def solution(n, colors):
    data= set(colors)
    result = list(permutations(data,len(data)))
    answer=[]
    for i in result: #(1,2,3)
        newcolors=copy.deepcopy(colors)
        ary=[]
        for j in i: # 1
            num=1
            idx=-1
            cnt=0
            while j in newcolors:
                if cnt != 0:
                    if idx == newcolors.index(j):
                        num += 1
                    else:                      
                        ary.append(num)
                        num = 1               
                idx=newcolors.index(j)
                newcolors.remove(j)
                cnt += 1
            ary.append(num)
        sum = 0
        for j in ary:
            sum += j**2
        answer.append(sum)

    return max(answer)